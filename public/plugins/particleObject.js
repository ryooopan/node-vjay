// Generated by CoffeeScript 1.4.0
(function() {
  var DistanceBetween, TweenCalculation;

  DistanceBetween = function(p1, p2) {
    var dx, dy;
    dx = p2.x - p1.x;
    dy = p2.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };

  TweenCalculation = function(rate, startVal, endVal) {
    var val;
    val = -1 * (endVal - startVal) * rate * (rate - 2) + startVal;
    return val;
  };

  this.ParticleObject = (function() {

    function ParticleObject(context1, context2) {
      var _this = this;
      this.Width = window.innerWidth;
      this.Height = window.innerHeight;
      this.context1 = context1;
      this.context2 = context2;
      this.lastTime = new Date().getTime();
      this.timeSum = 0;
      this.DENSITY = .75;
      this.FRICTION = 1.14;
      this.Mouse_Pull = 0.2;
      this.DETAIL = 16;
      this.AOE = 100;
      this.rad = 150;
      this.velo = 60;
      this.TWITCH_INTERVAL = .8;
      this.FORM_CHANGE_INTERVAL = 4;
      this.waveStatus = false;
      this.openingStatus = false;
      this.particleObjectAnimation = true;
      this.shapeID = 0;
      this.ms = {
        x: 0,
        y: 0
      };
      this.mp = {
        x: 0,
        y: 0
      };
      this.particles1 = [];
      this.particles2 = [];
//      $(document).bind('mousemove', function(event) {
//        return _this.mouseMoveFunc(event.pageX, event.pageY);
//      });
    }

    ParticleObject.prototype.init = function() {
      var forceRandom, i, particle, rRan, theta, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _results, _results1;
      switch (this.shapeID) {
        case 0:
          for (i = _i = 0, _ref = this.DETAIL - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            forceRandom = Math.random() * 100 - 50;
            theta = i / this.DETAIL * Math.PI * 2;
            rRan = 80 * Math.random();
            particle = {
              x: this.Width / 2 + (this.rad + rRan) * Math.cos(theta),
              y: this.Height / 2 + (this.rad + rRan) * Math.sin(theta),
              original: {
                x: this.Width / 2 + (this.rad + rRan) * Math.cos(theta),
                y: this.Height / 2 + (this.rad + rRan) * Math.sin(theta)
              },
              velocity: {
                x: 0,
                y: 0
              },
              force: {
                x: forceRandom * Math.cos(theta),
                y: forceRandom * Math.sin(theta)
              },
              mass: 10
            };
            this.particles1.push(particle);
          }
          _results = [];
          for (i = _j = 0, _ref1 = this.DETAIL - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            forceRandom = Math.random() * 100 - 50;
            theta = i / this.DETAIL * Math.PI * 2;
            rRan = 80 * Math.random();
            particle = {
              x: this.Width / 2 + (this.rad + rRan) * Math.cos(theta),
              y: this.Height / 2 + (this.rad + rRan) * Math.sin(theta),
              original: {
                x: this.Width / 2 + (this.rad + rRan) * Math.cos(theta),
                y: this.Height / 2 + (this.rad + rRan) * Math.sin(theta)
              },
              velocity: {
                x: 0,
                y: 0
              },
              force: {
                x: forceRandom * Math.cos(theta),
                y: forceRandom * Math.sin(theta)
              },
              mass: 10
            };
            _results.push(this.particles2.push(particle));
          }
          return _results;
          break;
        case 2:
          for (i = _k = 0, _ref2 = this.DETAIL - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
            forceRandom = Math.random() * 100 - 50;
            theta = i / this.DETAIL * Math.PI * 2;
            rRan = 80 * Math.random();
            particle = {
              x: this.Width / (this.DETAIL - 5) * (i - 2),
              y: 2 / 5 * this.Height,
              original: {
                x: this.Width / (this.DETAIL - 5) * (i - 2),
                y: 2 / 5 * this.Height
              },
              velocity: {
                x: 0,
                y: 0
              },
              force: {
                x: 0,
                y: 60 * Math.random() - 30
              },
              mass: 10
            };
            this.particles1.push(particle);
          }
          _results1 = [];
          for (i = _l = 0, _ref3 = this.DETAIL - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
            forceRandom = Math.random() * 100 - 50;
            theta = Math.PI / 2;
            rRan = 80 * Math.random();
            particle = {
              x: this.Width / (this.DETAIL - 5) * (i - 2),
              y: 3 / 5 * this.Height,
              original: {
                x: this.Width / (this.DETAIL - 5) * (i - 2),
                y: 3 / 5 * this.Height
              },
              velocity: {
                x: 0,
                y: 0
              },
              force: {
                x: forceRandom * Math.cos(theta),
                y: forceRandom * Math.sin(theta)
              },
              mass: 10
            };
            _results1.push(this.particles2.push(particle));
          }
          return _results1;
      }
    };

    ParticleObject.prototype.formChangeFunc = function(v) {
      this.velo = v;
      this.formChangeTImer = this.FORM_CHANGE_INTERVAL + 1;
    }
    
    ParticleObject.prototype.mouseMoveFunc = function(posX, posY) {
      this.ms.x = Math.max(Math.min(posX - this.mp.x, 40), -40);
      this.ms.y = Math.max(Math.min(posY - this.mp.y, 40), -40);
      this.mp.x = posX;
      return this.mp.y = posY;
    };

    ParticleObject.prototype.resetTimer = function() {
      this.timeSum = 0;
      this.lastTime = new Date().getTime();
      if (this.shapeID === 0) {
        this.twitchTime = 0;
        return this.formChangeTImer = 0;
      }
    };

    ParticleObject.prototype.transfer = function() {
      var futurePt, i, particle, pt, rRan, theta, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (this.shapeID === 0) {
        this.shapeID = 1;
        this.waveStatus = true;
      }
      if (this.shapeID === 2) {
        this.shapeID = 3;
        this.openingStatus = true;
      }
      console.log("this.shapeID: " + this.shapeID);
      if (this.shapeID === 1 && this.waveStatus) {
        this.openingStatus = true;
        this.waveStatus = false;
        this.tempParticle01 = [];
        this.futureParticle01 = [];
        this.tempParticle02 = [];
        this.futureParticle02 = [];
        _ref = this.particles1;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          particle = _ref[i];
          pt = {
            x: particle.original.x,
            y: particle.original.y
          };
          this.tempParticle01.push(pt);
          futurePt = {
            x: this.Width / (this.DETAIL - 5) * (i - 2),
            y: 3 / 5 * this.Height
          };
          this.futureParticle01.push(futurePt);
        }
        _ref1 = this.particles2;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          particle = _ref1[i];
          pt = {
            x: particle.original.x,
            y: particle.original.y
          };
          this.tempParticle02.push(pt);
          futurePt = {
            x: this.Width / (this.DETAIL - 5) * (i - 2),
            y: 2 / 5 * this.Height
          };
          this.futureParticle02.push(futurePt);
        }
        this.transferTimer = 0;
        this.transferDuration = .3;
        this.TWITCH_INTERVAL = .6;
        this.twitchTime = 0;
        this.lastTime = new Date().getTime();
      }
      if (this.shapeID === 3 && this.openingStatus) {
        this.openingStatus = false;
        this.waveStatus = true;
        console.log("this.shapeID " + this.shapeID);
        this.tempParticle01 = [];
        this.futureParticle01 = [];
        this.tempParticle02 = [];
        this.futureParticle02 = [];
        for (i = _k = 0, _ref2 = this.DETAIL - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          theta = i / this.DETAIL * Math.PI * 2;
          rRan = 80 * Math.random();
          futurePt = {
            x: this.Width / 2 + (this.rad + rRan) * Math.cos(theta),
            y: this.Height / 2 + (this.rad + rRan) * Math.sin(theta)
          };
          this.futureParticle01.push(futurePt);
          pt = {
            x: this.particles1[i].original.x,
            y: this.particles1[i].original.y
          };
          this.tempParticle01.push(pt);
        }
        for (i = _l = 0, _ref3 = this.DETAIL - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
          theta = i / this.DETAIL * Math.PI * 2;
          rRan = 80 * Math.random();
          futurePt = {
            x: this.Width / 2 + (this.rad + rRan) * Math.cos(theta),
            y: this.Height / 2 + (this.rad + rRan) * Math.sin(theta)
          };
          this.futureParticle02.push(futurePt);
          pt = {
            x: this.particles2[i].original.x,
            y: this.particles2[i].original.y
          };
          this.tempParticle02.push(pt);
        }
        this.twitchTime = 0;
        this.formChangeTImer = 0;
        this.transferTimer = 0;
        return this.TWITCH_INTERVAL = .8;
      }
    };

    ParticleObject.prototype.update = function() {
      var curTime, dt;
      curTime = new Date().getTime();
      dt = (curTime - this.lastTime) / 1000;
      switch (this.shapeID) {
        case 0:
          this.slime(dt);
          break;
        case 1:
          this.slimeToWave(dt);
          break;
        case 2:
          this.wave(dt);
          break;
        case 3:
          this.waveToSlime(dt);
      }
      return this.lastTime = curTime;
    };

    ParticleObject.prototype.slime = function(dt) {
      var distance, force, forceRandom, i, lastPt, next, particle, previous, rRan, theta, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3;
      this.twitchTime += dt;
      //this.formChangeTImer += dt;
      if (this.twitchTime > this.TWITCH_INTERVAL) {
        for (i = _i = 0, _ref = this.DETAIL - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.particles1[i].velocity.x += Math.random() * 10 - 5;
          this.particles1[i].velocity.x += Math.random() * 10 - 5;
          this.particles2[i].velocity.x += Math.random() * 10 - 5;
          this.particles2[i].velocity.x += Math.random() * 10 - 5;
        }
        this.twitchTime -= this.TWITCH_INTERVAL;
      }
      if (this.formChangeTImer > this.FORM_CHANGE_INTERVAL) {
        for (i = _j = 0, _ref1 = this.DETAIL - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          theta = i / this.DETAIL * Math.PI * 2;
          forceRandom = Math.random() * this.velo - 30;
          rRan = 80 * Math.random() - 40;
          this.particles1[i].original.x += rRan * Math.cos(theta);
          this.particles1[i].original.y += rRan * Math.sin(theta);
          this.particles1[i].force.x += forceRandom * Math.cos(theta);
          this.particles1[i].force.y += forceRandom * Math.sin(theta);
          forceRandom = Math.random() * this.velo - 30;
          rRan = 80 * Math.random() - 40;
          this.particles2[i].original.x += rRan * Math.cos(theta);
          this.particles2[i].original.y += rRan * Math.sin(theta);
          this.particles2[i].force.x += forceRandom * Math.cos(theta);
          this.particles2[i].force.y += forceRandom * Math.sin(theta);
        }
        this.formChangeTImer -= this.FORM_CHANGE_INTERVAL;
      }
      this.context1.fillStyle = "rgba(200, 200, 200, .8)";
      this.context1.beginPath();
      _ref2 = this.particles1;
      for (i = _k = 0, _len = _ref2.length; _k < _len; i = ++_k) {
        particle = _ref2[i];
        if (i === 0) {
          previous = this.particles1[this.DETAIL - 1];
        } else {
          previous = this.particles1[i - 1];
        }
        if (i === this.DETAIL - 1) {
          next = this.particles1[0];
        } else {
          next = this.particles1[i + 1];
        }
        force = {
          x: 0,
          y: 0
        };
        force.y += -this.DENSITY * (previous.y - particle.y);
        force.x += -this.DENSITY * (previous.x - particle.x);
        force.y += this.DENSITY * (particle.y - next.y);
        force.x += this.DENSITY * (particle.x - next.x);
        force.y += this.DENSITY * (particle.y - particle.original.y);
        force.x += this.DENSITY * (particle.x - particle.original.x);
        particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
        particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
        particle.velocity.x /= this.FRICTION;
        particle.force.x /= this.FRICTION;
        particle.x += particle.velocity.x;
        particle.velocity.y /= this.FRICTION;
        particle.force.y /= this.FRICTION;
        particle.y += particle.velocity.y;
        distance = DistanceBetween(this.mp, particle);
        if (distance < this.AOE) {
          distance = DistanceBetween(this.mp, {
            x: particle.original.x,
            y: particle.original.y
          });
          this.ms.x = this.ms.x * 0.98;
          this.ms.y = this.ms.y * 0.98;
          particle.force.y += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.y * 1.25;
          particle.force.x += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.x * 1.25;
        }
        if (i === 0) {
          lastPt = {
            x: (particle.x + previous.x) / 2,
            y: (particle.y + previous.y) / 2
          };
          this.context1.moveTo(lastPt.x, lastPt.y);
        } else {
          this.context1.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
        }
      }
      this.context1.quadraticCurveTo(this.particles1[this.DETAIL - 1].x, this.particles1[this.DETAIL - 1].y, lastPt.x, lastPt.y);
      this.context1.closePath();
      this.context1.fill();
      this.context2.fillStyle = "rgba(120, 120, 120, .5)";
      this.context2.beginPath();
      _ref3 = this.particles2;
      for (i = _l = 0, _len1 = _ref3.length; _l < _len1; i = ++_l) {
        particle = _ref3[i];
        if (i === 0) {
          previous = this.particles2[this.DETAIL - 1];
        } else {
          previous = this.particles2[i - 1];
        }
        if (i === this.DETAIL - 1) {
          next = this.particles2[0];
        } else {
          next = this.particles2[i + 1];
        }
        force = {
          x: 0,
          y: 0
        };
        force.y += -this.DENSITY * (previous.y - particle.y);
        force.x += -this.DENSITY * (previous.x - particle.x);
        force.y += this.DENSITY * (particle.y - next.y);
        force.x += this.DENSITY * (particle.x - next.x);
        force.y += this.DENSITY * (particle.y - particle.original.y);
        force.x += this.DENSITY * (particle.x - particle.original.x);
        particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
        particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
        particle.velocity.x /= this.FRICTION;
        particle.force.x /= this.FRICTION;
        particle.x += particle.velocity.x;
        particle.velocity.y /= this.FRICTION;
        particle.force.y /= this.FRICTION;
        particle.y += particle.velocity.y;
        distance = DistanceBetween(this.mp, particle);
        if (distance < this.AOE) {
          distance = DistanceBetween(this.mp, {
            x: particle.original.x,
            y: particle.original.y
          });
          this.ms.x = this.ms.x * 0.98;
          this.ms.y = this.ms.y * 0.98;
          particle.force.y += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.y;
          particle.force.x += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.x;
        }
        if (i === 0) {
          lastPt = {
            x: (particle.x + previous.x) / 2,
            y: (particle.y + previous.y) / 2
          };
          this.context2.moveTo(lastPt.x, lastPt.y);
        } else {
          this.context2.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
        }
      }
      this.context2.quadraticCurveTo(this.particles2[this.DETAIL - 1].x, this.particles2[this.DETAIL - 1].y, lastPt.x, lastPt.y);
      this.context2.closePath();
      return this.context2.fill();
    };

    ParticleObject.prototype.slimeToWave = function(dt) {
      var distance, force, i, lastPt, next, particle, previous, rate, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      this.twitchTime += dt;
      if (this.twitchTime > this.TWITCH_INTERVAL) {
        for (i = _i = 1, _ref = this.DETAIL - 2; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          this.particles1[i].force.x += Math.random() * 10 - 5;
          this.particles1[i].force.y += Math.random() * 10 - 5;
          this.particles2[i].force.x += Math.random() * 10 - 5;
          this.particles2[i].force.y += Math.random() * 10 - 5;
        }
        this.twitchTime -= this.TWITCH_INTERVAL;
      }
      this.transferTimer += dt;
      rate = this.transferTimer / this.transferDuration;
      if (rate < 1) {
        this.context1.fillStyle = "rgba(30, 30, 30, " + (.3 * (1 - rate)) + ")";
        this.context1.beginPath();
        _ref1 = this.particles1;
        for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
          particle = _ref1[i];
          particle.original.x = TweenCalculation(rate, this.tempParticle01[i].x, this.futureParticle01[i].x);
          particle.original.y = TweenCalculation(rate, this.tempParticle01[i].y, this.futureParticle01[i].y);
          if (i === 0) {
            previous = this.particles1[this.DETAIL - 1];
          } else {
            previous = this.particles1[i - 1];
          }
          force = {
            x: 0,
            y: 0
          };
          force.y += this.DENSITY * (particle.y - particle.original.y) * 40;
          force.x += this.DENSITY * (particle.x - particle.original.x) * 40;
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          if (i === 0) {
            lastPt = {
              x: (particle.x + previous.x) / 2,
              y: (particle.y + previous.y) / 2
            };
            this.context1.moveTo(lastPt.x, lastPt.y);
          } else {
            this.context1.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context1.quadraticCurveTo(this.particles1[this.DETAIL - 1].x, this.particles1[this.DETAIL - 1].y, lastPt.x, lastPt.y);
        this.context1.closePath();
        this.context1.fill();
        this.context1.fillStyle = "rgba(30, 30, 30, " + rate + ")";
        this.context1.beginPath();
        this.context1.moveTo(this.particles1[1].x, this.particles1[1].y);
        _ref2 = this.particles1;
        for (i = _k = 0, _len1 = _ref2.length; _k < _len1; i = ++_k) {
          particle = _ref2[i];
          previous = this.particles1[i - 1];
          next = this.particles1[i + 1];
          if (previous && next) {
            this.context1.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.particles1[this.DETAIL - 1].y);
        this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.Height);
        this.context1.lineTo(this.particles1[0].x, this.Height);
        this.context1.closePath();
        this.context1.fill();
        this.context2.fillStyle = "rgba(120, 120, 120, " + (.3 * (1 - rate)) + ")";
        this.context2.beginPath();
        _ref3 = this.particles2;
        for (i = _l = 0, _len2 = _ref3.length; _l < _len2; i = ++_l) {
          particle = _ref3[i];
          particle.original.x = TweenCalculation(rate, this.tempParticle02[i].x, this.futureParticle02[i].x);
          particle.original.y = TweenCalculation(rate, this.tempParticle02[i].y, this.futureParticle02[i].y);
          if (i === 0) {
            previous = this.particles2[this.DETAIL - 1];
          } else {
            previous = this.particles2[i - 1];
          }
          force = {
            x: 0,
            y: 0
          };
          force.y += this.DENSITY * (particle.y - particle.original.y) * 40;
          force.x += this.DENSITY * (particle.x - particle.original.x) * 40;
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          if (i === 0) {
            lastPt = {
              x: (particle.x + previous.x) / 2,
              y: (particle.y + previous.y) / 2
            };
            this.context2.moveTo(lastPt.x, lastPt.y);
          } else {
            this.context2.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context2.quadraticCurveTo(this.particles2[this.DETAIL - 1].x, this.particles2[this.DETAIL - 1].y, lastPt.x, lastPt.y);
        this.context2.closePath();
        this.context2.fill();
        this.context2.fillStyle = "rgba(120, 120, 120, " + rate + ")";
        this.context2.beginPath();
        this.context2.moveTo(this.particles1[1].x, this.particles1[1].y);
        _ref4 = this.particles2;
        for (i = _m = 0, _len3 = _ref4.length; _m < _len3; i = ++_m) {
          particle = _ref4[i];
          previous = this.particles2[i - 1];
          next = this.particles2[i + 1];
          if (previous && next) {
            this.context2.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.particles2[this.DETAIL - 1].y);
        this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.Height);
        this.context2.lineTo(this.particles2[0].x, this.Height);
        this.context2.closePath();
        return this.context2.fill();
      } else if (rate < 3 && rate > 1) {
        this.context1.fillStyle = "rgba(30, 30, 30, 1)";
        this.context1.beginPath();
        this.context1.moveTo(this.particles1[1].x, this.particles1[1].y);
        _ref5 = this.particles1;
        for (i = _n = 0, _len4 = _ref5.length; _n < _len4; i = ++_n) {
          particle = _ref5[i];
          force = {
            x: 0,
            y: 0
          };
          force.y += this.DENSITY * (particle.y - particle.original.y);
          force.x += this.DENSITY * (particle.x - particle.original.x);
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          distance = DistanceBetween(this.mp, particle);
          if (distance < this.AOE) {
            distance = DistanceBetween(this.mp, {
              x: particle.original.x,
              y: particle.original.y
            });
            this.ms.x = this.ms.x * 0.98;
            this.ms.y = this.ms.y * 0.98;
            particle.force.y += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.y;
            particle.force.x += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.x;
          }
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          previous = this.particles1[i - 1];
          next = this.particles1[i + 1];
          if (previous && next) {
            this.context1.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.particles1[this.DETAIL - 1].y);
        this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.Height);
        this.context1.lineTo(this.particles1[0].x, this.Height);
        this.context1.closePath();
        this.context1.fill();
        this.context2.fillStyle = "rgba(120, 120, 120, 1)";
        this.context2.beginPath();
        this.context2.moveTo(this.particles2[1].x, this.particles2[1].y);
        _ref6 = this.particles2;
        for (i = _o = 0, _len5 = _ref6.length; _o < _len5; i = ++_o) {
          particle = _ref6[i];
          force = {
            x: 0,
            y: 0
          };
          force.y += this.DENSITY * (particle.y - particle.original.y);
          force.x += this.DENSITY * (particle.x - particle.original.x);
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          distance = DistanceBetween(this.mp, particle);
          if (distance < this.AOE) {
            distance = DistanceBetween(this.mp, {
              x: particle.original.x,
              y: particle.original.y
            });
            this.ms.x = this.ms.x * 0.98;
            this.ms.y = this.ms.y * 0.98;
            particle.force.y += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.y;
            particle.force.x += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.x;
          }
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          previous = this.particles2[i - 1];
          next = this.particles2[i + 1];
          if (previous && next) {
            this.context2.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.particles2[this.DETAIL - 1].y);
        this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.Height);
        this.context2.lineTo(this.particles2[0].x, this.Height);
        this.context2.fill();
        return this.context2.closePath();
      } else {
        this.TWITCH_INTERVAL = 1.2;
        this.twitchTime = 0;
        this.wave(0);
        return this.shapeID = 2;
      }
    };

    ParticleObject.prototype.wave = function(dt) {
      var distance, force, i, next, particle, previous, randomVal, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      var velo = this.velo / 5;
      this.twitchTime += dt;
      if (this.formChangeTImer > this.FORM_CHANGE_INTERVAL) {
      //if (this.twitchTime > this.TWITCH_INTERVAL) {
        for (i = _i = 1, _ref = this.DETAIL - 2; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          this.particles1[i].force.x += Math.random() * velo - 5;
          this.particles1[i].force.y += Math.random() * velo - 5;
          this.particles2[i].force.x += Math.random() * velo - 5;
          this.particles2[i].force.y += Math.random() * velo - 5;
        }
	this.formChangeTImer -= this.FORM_CHANGE_INTERVAL;
        //this.twitchTime -= this.TWITCH_INTERVAL;
      }
      this.context1.fillStyle = "rgb(30, 30, 30)";
      this.context1.beginPath();
      this.context1.moveTo(this.particles1[1].x, this.particles1[1].y);
      _ref1 = this.particles1;
      for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
        particle = _ref1[i];
        previous = this.particles1[i - 1];
        next = this.particles1[i + 1];
        if (previous && next) {
          force = {
            x: 0,
            y: 0
          };
          force.y += -this.DENSITY * (previous.y - particle.y);
          force.x += -this.DENSITY * (previous.x - particle.x);
          force.y += this.DENSITY * (particle.y - next.y);
          force.x += this.DENSITY * (particle.x - next.x);
          force.y += this.DENSITY / 15 * (particle.y - particle.original.y);
          force.x += this.DENSITY / 15 * (particle.x - particle.original.x);
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          distance = DistanceBetween(this.mp, particle);
          if (distance < this.AOE) {
            distance = DistanceBetween(this.mp, {
              x: particle.original.x,
              y: particle.original.y
            });
            this.ms.x = this.ms.x * 0.98;
            this.ms.y = this.ms.y * 0.98;
            randomVal = Math.random();
            particle.force.y += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.y * .75 * randomVal;
            particle.force.x += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.x * .75 * randomVal;
          }
          this.context1.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
        }
      }
      this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.particles1[this.DETAIL - 1].y);
      this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.Height);
      this.context1.lineTo(this.particles1[0].x, this.Height);
      this.context1.closePath();
      this.context1.fill();
      this.context2.fillStyle = "rgb(120, 120, 120)";
      this.context2.beginPath();
      this.context2.moveTo(this.particles2[1].x, this.particles2[1].y);
      _ref2 = this.particles2;
      for (i = _k = 0, _len1 = _ref2.length; _k < _len1; i = ++_k) {
        particle = _ref2[i];
        previous = this.particles2[i - 1];
        next = this.particles2[i + 1];
        if (previous && next) {
          force = {
            x: 0,
            y: 0
          };
          force.y += -this.DENSITY * (previous.y - particle.y);
          force.x += -this.DENSITY * (previous.x - particle.x);
          force.y += this.DENSITY * (particle.y - next.y);
          force.x += this.DENSITY * (particle.x - next.x);
          force.y += this.DENSITY / 15 * (particle.y - particle.original.y);
          force.x += this.DENSITY / 15 * (particle.x - particle.original.x);
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          distance = DistanceBetween(this.mp, particle);
          if (distance < this.AOE) {
            distance = DistanceBetween(this.mp, {
              x: particle.original.x,
              y: particle.original.y
            });
            this.ms.x = this.ms.x * 0.98;
            this.ms.y = this.ms.y * 0.98;
            particle.force.y += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.y * .75;
            particle.force.x += (this.Mouse_Pull * (1 - (distance / this.AOE))) * this.ms.x * .75;
          }
          this.context2.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
        }
      }
      this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.particles2[this.DETAIL - 1].y);
      this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.Height);
      this.context2.lineTo(this.particles2[0].x, this.Height);
      this.context2.closePath();
      return this.context2.fill();
    };

    ParticleObject.prototype.waveToSlime = function(dt) {
      var force, i, lastPt, next, particle, previous, rate, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      console.log("waveToSlime");
      this.transferTimer += dt;
      rate = this.transferTimer / this.transferDuration;
      console.log("rate: " + rate);
      if (rate < 1) {
        this.context1.fillStyle = "rgba(30, 30, 30, " + (.3 * rate) + ")";
        this.context1.beginPath();
        _ref = this.particles1;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          particle = _ref[i];
          particle.original.x = TweenCalculation(rate, this.tempParticle01[i].x, this.futureParticle01[i].x);
          particle.original.y = TweenCalculation(rate, this.tempParticle01[i].y, this.futureParticle01[i].y);
          if (i === 0) {
            previous = this.particles1[this.DETAIL - 1];
          } else {
            previous = this.particles1[i - 1];
          }
          force = {
            x: 0,
            y: 0
          };
          force.y += this.DENSITY * (particle.y - particle.original.y) * 40;
          force.x += this.DENSITY * (particle.x - particle.original.x) * 40;
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          if (i === 0) {
            lastPt = {
              x: (particle.x + previous.x) / 2,
              y: (particle.y + previous.y) / 2
            };
            this.context1.moveTo(lastPt.x, lastPt.y);
          } else {
            this.context1.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context1.quadraticCurveTo(this.particles1[this.DETAIL - 1].x, this.particles1[this.DETAIL - 1].y, lastPt.x, lastPt.y);
        this.context1.closePath();
        this.context1.fill();
        this.context1.fillStyle = "rgba(30, 30, 30, " + (1 - rate) + ")";
        this.context1.beginPath();
        this.context1.moveTo(this.particles1[1].x, this.particles1[1].y);
        _ref1 = this.particles1;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          particle = _ref1[i];
          previous = this.particles1[i - 1];
          next = this.particles1[i + 1];
          if (previous && next) {
            this.context1.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.particles1[this.DETAIL - 1].y);
        this.context1.lineTo(this.particles1[this.DETAIL - 1].x, this.Height);
        this.context1.lineTo(this.particles1[0].x, this.Height);
        this.context1.closePath();
        this.context1.fill();
        this.context2.fillStyle = "rgba(120, 120, 120, " + (.3 * rate) + ")";
        this.context2.beginPath();
        _ref2 = this.particles2;
        for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
          particle = _ref2[i];
          particle.original.x = TweenCalculation(rate, this.tempParticle02[i].x, this.futureParticle02[i].x);
          particle.original.y = TweenCalculation(rate, this.tempParticle02[i].y, this.futureParticle02[i].y);
          if (i === 0) {
            previous = this.particles2[this.DETAIL - 1];
          } else {
            previous = this.particles2[i - 1];
          }
          force = {
            x: 0,
            y: 0
          };
          force.y += this.DENSITY * (particle.y - particle.original.y) * 40;
          force.x += this.DENSITY * (particle.x - particle.original.x) * 40;
          particle.velocity.y += -(force.y / particle.mass) + particle.force.y;
          particle.velocity.x += -(force.x / particle.mass) + particle.force.x;
          particle.velocity.x /= this.FRICTION;
          particle.force.x /= this.FRICTION;
          particle.x += particle.velocity.x;
          particle.velocity.y /= this.FRICTION;
          particle.force.y /= this.FRICTION;
          particle.y += particle.velocity.y;
          if (i === 0) {
            lastPt = {
              x: (particle.x + previous.x) / 2,
              y: (particle.y + previous.y) / 2
            };
            this.context2.moveTo(lastPt.x, lastPt.y);
          } else {
            this.context2.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context2.quadraticCurveTo(this.particles2[this.DETAIL - 1].x, this.particles2[this.DETAIL - 1].y, lastPt.x, lastPt.y);
        this.context2.closePath();
        this.context2.fill();
        this.context2.fillStyle = "rgba(120, 120, 120, " + (1 - rate) + ")";
        this.context2.beginPath();
        this.context2.moveTo(this.particles1[1].x, this.particles1[1].y);
        _ref3 = this.particles2;
        for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
          particle = _ref3[i];
          previous = this.particles2[i - 1];
          next = this.particles2[i + 1];
          if (previous && next) {
            this.context2.quadraticCurveTo(previous.x, previous.y, (previous.x + particle.x) / 2, (previous.y + particle.y) / 2);
          }
        }
        this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.particles2[this.DETAIL - 1].y);
        this.context2.lineTo(this.particles2[this.DETAIL - 1].x, this.Height);
        this.context2.lineTo(this.particles2[0].x, this.Height);
        this.context2.closePath();
        return this.context2.fill();
      } else {
        this.slime(0);
        return this.shapeID = 0;
      }
    };

    ParticleObject.prototype.resize = function(event) {
      var dx, dy, i, particle, prevHig, prevWid, xPos, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _results, _results1;
      prevWid = this.Width;
      prevHig = this.Height;
      this.Width = window.innerWidth;
      this.Height = window.innerHeight;
      if (this.shapeID < 1) {
        dx = (this.Width - prevWid) / 2;
        dy = (this.Height - prevHig) / 2;
        _ref = this.particles1;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          particle = _ref[_i];
          particle.original.x += dx;
          particle.original.y += dy;
        }
        _ref1 = this.particles2;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          particle = _ref1[_j];
          particle.original.x += dx;
          _results.push(particle.original.y += dy);
        }
        return _results;
      } else {
        _results1 = [];
        for (i = _k = 0, _ref2 = this.DETAIL - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          xPos = this.Width / (this.DETAIL - 5) * (i - 2);
          this.particles1[i].x = xPos;
          this.particles1[i].y = 3 / 5 * this.Height;
          this.particles1[i].original.x = xPos;
          this.particles1[i].original.y = 3 / 5 * this.Height;
          this.particles2[i].x = xPos;
          this.particles2[i].y = 2 / 5 * this.Height;
          this.particles2[i].original.x = xPos;
          _results1.push(this.particles2[i].original.y = 2 / 5 * this.Height);
        }
        return _results1;
      }
    };

    return ParticleObject;

  })();

}).call(this);
